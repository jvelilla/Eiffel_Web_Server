Eiffel Compilation Manager<br>Version 14.05.9.5158 GPL Edition - win64<br><br>Degree 6: Examining System<br>System Recompiled.<br>note<br>	description: "sample application root class"<br>	date: "$Date$"<br>	revision: "$Revision$"<br><br>class <br>	APPLICATION<br><br>create <br>	make<br><br>feature {NONE} -- Initialization<br><br>	default_create<br>			-- Process instances of classes with no creation clause.<br>			-- (Default: do nothing.)<br>			-- (from ANY)<br>		do<br>		end<br><br>	extra_feature (a: INTEGER_32)<br>		require<br>			number_out_of_range: a = 0<br>		local<br>			s: STRING_8<br>		do<br>			Io.put_string ("Number not out of range")<br>			Io.put_new_line<br>			create s.make_from_string ("abcd")<br>		ensure<br>			number_out_of_range: a = 0<br>		end<br><br>	make<br>			-- Run application.<br>		local<br>			a, c: INTEGER_32<br>			bal: ACCOUNT<br>		do<br>			Io.put_string ("Hello Eiffel World!%N")<br>			extra_feature (0)<br>			Io.put_string (a.out)<br>			create bal.make (10.to_double)<br>			bal.withdraw (5.to_double)<br>		end<br>	<br>feature -- Access<br><br>	argument (i: INTEGER_32): STRING_8<br>			-- `i'-th argument of command that started system execution<br>			-- (the command name if `i' = 0)<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			index_large_enough: i >= 0<br>			index_small_enough: i <= argument_count<br>		do<br>			Result := Internal_arguments.argument (i).as_string_8<br>		ensure -- from ARGUMENTS<br>			argument_not_void: Result /= Void<br>		end<br><br>	Argument_array: ARRAY [STRING_8]<br>			-- Array containing command name (position 0) and arguments<br>			-- (from ARGUMENTS)<br>		once<br>			Result := internal_argument_array<br>		ensure -- from ARGUMENTS<br>			argument_array_not_void: Result /= Void<br>			argument_array_compare_objects: Result.object_comparison<br>		end<br><br>	Command_line: STRING_8<br>			-- Total command line<br>			-- (from ARGUMENTS)<br>		local<br>			i: INTEGER_32<br>		once<br>			Result := Command_name.twin<br>			from<br>				i := 1<br>			until<br>				i > argument_count<br>			loop<br>				Result.append (" ")<br>				Result.append (argument (i))<br>				i := i + 1<br>			end<br>		ensure -- from ARGUMENTS<br>				Result.count >= Command_name.count<br>		end<br><br>	Command_name: STRING_8<br>			-- Name of command that started system execution<br>			-- (from ARGUMENTS)<br>		once<br>			Result := argument (0)<br>		ensure -- from ARGUMENTS<br>			definition: Result ~ argument (0)<br>		end<br><br>	generating_type: TYPE [detachable APPLICATION]<br>			-- Type of current object<br>			-- (type of which it is a direct instance)<br>			-- (from ANY)<br>		do<br>			Result := {detachable APPLICATION}<br>		ensure -- from ANY<br>			generating_type_not_void: Result /= Void<br>		end<br><br>	generator: STRING_8<br>			-- Name of current object's generating class<br>			-- (base class of the type of which it is a direct instance)<br>			-- (from ANY)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			generator_not_void: Result /= Void<br>			generator_not_empty: not Result.is_empty<br>		end<br>	<br>feature -- Measurement<br><br>	argument_count: INTEGER_32<br>			-- Number of arguments given to command that started<br>			-- system execution (command name does not count)<br>			-- (from ARGUMENTS)<br>		do<br>			Result := Internal_arguments.argument_count<br>		ensure -- from ARGUMENTS<br>			argument_count_positive: Result >= 0<br>		end<br>	<br>feature -- Comparison<br><br>	frozen deep_equal (a: detachable ANY; b: like arg #1): BOOLEAN<br>			-- Are `a' and `b' either both void<br>			-- or attached to isomorphic object structures?<br>			-- (from ANY)<br>		do<br>			if a = Void then<br>				Result := b = Void<br>			else<br>				Result := b /= Void and then a.is_deep_equal (b)<br>			end<br>		ensure -- from ANY<br>			shallow_implies_deep: standard_equal (a, b) implies Result<br>			both_or_none_void: (a = Void) implies (Result = (b = Void))<br>			same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))<br>			symmetric: Result implies deep_equal (b, a)<br>		end<br><br>	frozen equal (a: detachable ANY; b: like arg #1): BOOLEAN<br>			-- Are `a' and `b' either both void or attached<br>			-- to objects considered equal?<br>			-- (from ANY)<br>		do<br>			if a = Void then<br>				Result := b = Void<br>			else<br>				Result := b /= Void and then a.is_equal (b)<br>			end<br>		ensure -- from ANY<br>			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.is_equal (b))<br>		end<br><br>	frozen is_deep_equal (other: attached APPLICATION): BOOLEAN<br>			-- Are `Current' and `other' attached to isomorphic object structures?<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			shallow_implies_deep: standard_is_equal (other) implies Result<br>			same_type: Result implies same_type (other)<br>			symmetric: Result implies other.is_deep_equal (Current)<br>		end<br><br>	is_equal (other: attached APPLICATION): BOOLEAN<br>			-- Is `other' attached to an object considered<br>			-- equal to current object?<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			symmetric: Result implies other ~ Current<br>			consistent: standard_is_equal (other) implies Result<br>		end<br><br>	frozen standard_equal (a: detachable ANY; b: like arg #1): BOOLEAN<br>			-- Are `a' and `b' either both void or attached to<br>			-- field-by-field identical objects of the same type?<br>			-- Always uses default object comparison criterion.<br>			-- (from ANY)<br>		do<br>			if a = Void then<br>				Result := b = Void<br>			else<br>				Result := b /= Void and then a.standard_is_equal (b)<br>			end<br>		ensure -- from ANY<br>			definition: Result = (a = Void and b = Void) or else ((a /= Void and b /= Void) and then a.standard_is_equal (b))<br>		end<br><br>	frozen standard_is_equal (other: attached APPLICATION): BOOLEAN<br>			-- Is `other' attached to an object of the same type<br>			-- as current object, and field-by-field identical to it?<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			same_type: Result implies same_type (other)<br>			symmetric: Result implies other.standard_is_equal (Current)<br>		end<br>	<br>feature -- Status report<br><br>	coalesced_character_option_value (o: CHARACTER_8): detachable STRING_8<br>			-- The value, if any, specified for character option `o' on<br>			-- the command line.<br>			-- Defined as follows (where 'X' is the current 'option_sign' and<br>			-- 'xx' is an arbitrary, possibly empty sequence of characters):<br>			--   `val' if command line includes an argument of the form `Xxxoval'<br>			--	   (this may be an empty string if argument is just `Xxxo').<br>			--   Void otherwise.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			o_non_null: o /= '%U'<br>		local<br>			p: INTEGER_32<br>			l: STRING_8<br>		do<br>			p := index_of_character_option (o)<br>			if p /= 0 then<br>				l := Argument_array.item (p).twin<br>				if Option_sign.item /= '%U' then<br>					l.remove (1)<br>				end<br>				Result := l.substring (l.index_of (o, 1) + 1, l.count)<br>			end<br>		end<br><br>	coalesced_option_character_value (o: CHARACTER_8): detachable STRING_8<br>		obsolete "Use coalesced_character_option_value instead."<br>			-- (from ARGUMENTS)<br>		do<br>			Result := coalesced_character_option_value (o)<br>		end<br><br>	coalesced_option_word_value (opt: STRING_8): detachable STRING_8<br>		obsolete "Use coalesced_word_option_value instead."<br>			-- (from ARGUMENTS)<br>		do<br>			Result := coalesced_word_option_value (opt)<br>		end<br><br>	coalesced_word_option_value (opt: STRING_8): detachable STRING_8<br>			-- The value, if any, specified for word option `opt' on the<br>			-- command line.<br>			-- Defined as follows (where X is the current Option_sign):<br>			--   `val' if command line includes an argument of the form `Xoptval'<br>			--	   (this may be an empty string if argument is just `Xopt').<br>			--   Void otherwise.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			opt_non_void: opt /= Void<br>			opt_meaningful: not opt.is_empty<br>		local<br>			p: INTEGER_32<br>			l: STRING_8<br>		do<br>			p := index_of_beginning_with_word_option (opt)<br>			if p /= 0 then<br>				l := Argument_array.item (p).twin<br>				if Option_sign.item /= '%U' then<br>					l.remove (1)<br>				end<br>				Result := l.substring (opt.count + 1, l.count)<br>			end<br>		end<br><br>	conforms_to (other: ANY): BOOLEAN<br>			-- Does type of current object conform to type<br>			-- of `other' (as per Eiffel: The Language, chapter 13)?<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		external<br>			"built_in"<br>		end<br><br>	has_character_option (o: CHARACTER_8): INTEGER_32<br>		obsolete "Use index_of_character_option instead."<br>			-- (from ARGUMENTS)<br>		do<br>			Result := index_of_character_option (o)<br>		end<br><br>	has_word_option (opt: STRING_8): INTEGER_32<br>		obsolete "Use index_of_word_option instead."<br>			-- (from ARGUMENTS)<br>		do<br>			Result := index_of_word_option (opt)<br>		end<br><br>	index_of_beginning_with_word_option (opt: STRING_8): INTEGER_32<br>			-- Does command line specify argument beginning with word<br>			-- option `opt' and, if so, at what position?<br>			-- If one of the arguments in list of space-separated arguments<br>			-- is `Xoptxx', where `X' is the current Option_sign, 'xx'<br>			-- is arbitrary, possibly empty sequence of characters,<br>			-- then index of this argument in list;<br>			-- else 0.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			opt_non_void: opt /= Void<br>			opt_meaningful: not opt.is_empty<br>		local<br>			i: INTEGER_32<br>		do<br>			from<br>				i := 1<br>			until<br>				i > argument_count or else option_word_begins_with (Argument_array.item (i), opt)<br>			loop<br>				i := i + 1<br>			end<br>			if i <= argument_count then<br>				Result := i<br>			end<br>		end<br><br>	index_of_character_option (o: CHARACTER_8): INTEGER_32<br>			-- Does command line specify character option `o' and, if so,<br>			-- at what position?<br>			-- If one of the space-separated arguments is of the form `Xxxoyy',<br>			-- where `X' is the current Option_sign, `xx' and `yy'<br>			-- are arbitrary, possibly empty sequences of characters,<br>			-- then index of this argument in list of arguments;<br>			-- else 0.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			o_non_null: o /= '%U'<br>		local<br>			i: INTEGER_32<br>		do<br>			from<br>				i := 1<br>			until<br>				i > argument_count or else option_character_equal (Argument_array.item (i), o)<br>			loop<br>				i := i + 1<br>			end<br>			if i <= argument_count then<br>				Result := i<br>			end<br>		end<br><br>	index_of_word_option (opt: STRING_8): INTEGER_32<br>			-- Does command line specify word option `opt' and, if so,<br>			-- at what position?<br>			-- If one of the arguments in list of space-separated arguments<br>			-- is `Xopt', where `X' is the current Option_sign,<br>			-- then index of this argument in list;<br>			-- else 0.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			opt_non_void: opt /= Void<br>			opt_meaningful: not opt.is_empty<br>		local<br>			i: INTEGER_32<br>		do<br>			from<br>				i := 1<br>			until<br>				i > argument_count or else option_word_equal (Argument_array.item (i), opt)<br>			loop<br>				i := i + 1<br>			end<br>			if i <= argument_count then<br>				Result := i<br>			end<br>		end<br><br>	Option_sign: CHARACTER_8_REF<br>			-- The character used to signal options on the command line.<br>			-- This can be '%U' if no sign is necessary for the argument<br>			-- to be an option<br>			-- Default is '-'<br>			-- (from ARGUMENTS)<br>		once<br>			create Result<br>			Result.set_item ('-')<br>		end<br><br>	same_type (other: ANY): BOOLEAN<br>			-- Is type of current object identical to type of `other'?<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			definition: Result = (conforms_to (other) and other.conforms_to (Current))<br>		end<br><br>	separate_character_option_value (o: CHARACTER_8): detachable STRING_8<br>			-- The value, if any, specified after character option `o' on<br>			-- the command line.<br>			-- This is one of the following (where `X' is the current<br>			-- Option_sign, `xx' and 'yy' are arbitrary, possibly empty<br>			-- sequences of characters):<br>			--   `val' if command line includes two consecutive arguments<br>			--	   of the form `Xxxoyy' and `val' respectively.<br>			--   Empty string if command line includes argument `Xxxoyy', which is<br>			--	   either last argument or followed by argument starting with `X'.<br>			--   Void if there is no argument of the form `Xxxoyy'.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			o_non_null: o /= '%U'<br>		local<br>			p: INTEGER_32<br>		do<br>			p := index_of_character_option (o)<br>			if p /= 0 then<br>				if p = argument_count or else Argument_array.item (p + 1).item (1) = Option_sign.item then<br>					Result := ""<br>				else<br>					Result := Argument_array.item (p + 1)<br>				end<br>			end<br>		end<br><br>	separate_word_option_value (opt: STRING_8): detachable STRING_8<br>			-- The value, if any, specified after word option `opt' on the<br>			-- command line.<br>			-- This is one of the following (where `X' is the current Option_sign):<br>			--   `val' if command line includes two consecutive arguments<br>			--	   of the form `Xopt' and `val' respectively.<br>			--   Empty string if command line includes argument `Xopt', which is<br>			--	   either last argument or followed by argument starting with `X'.<br>			--   Void if no `Xopt' argument.<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			opt_non_void: opt /= Void<br>			opt_meaningful: not opt.is_empty<br>		local<br>			p: INTEGER_32<br>		do<br>			p := index_of_word_option (opt)<br>			if p /= 0 then<br>				if p = argument_count or else Argument_array.item (p + 1).item (1) = Option_sign.item then<br>					Result := ""<br>				else<br>					Result := Argument_array.item (p + 1)<br>				end<br>			end<br>		end<br>	<br>feature -- Status setting<br><br>	set_option_sign (c: CHARACTER_8)<br>			-- Make `c' the option sign.<br>			-- Use'%U' if no sign is necessary for the argument to<br>			-- be an option<br>			-- (from ARGUMENTS)<br>		do<br>			Option_sign.set_item (c)<br>		end<br>	<br>feature -- Duplication<br><br>	frozen clone (other: detachable ANY): like other<br>		obsolete "Use `twin' instead."<br>			-- Void if `other' is void; otherwise new object<br>			-- equal to `other'<br>			--<br>			-- For non-void `other', clone calls copy;<br>			-- to change copying/cloning semantics, redefine copy.<br>			-- (from ANY)<br>		do<br>			if other /= Void then<br>				Result := other.twin<br>			end<br>		ensure -- from ANY<br>			equal: Result ~ other<br>		end<br><br>	copy (other: attached APPLICATION)<br>			-- Update current object using fields of object attached<br>			-- to `other', so as to yield equal objects.<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>			type_identity: same_type (other)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			is_equal: Current ~ other<br>		end<br><br>	frozen deep_clone (other: detachable ANY): like other<br>		obsolete "Use `deep_twin' instead."<br>			-- Void if `other' is void: otherwise, new object structure<br>			-- recursively duplicated from the one attached to `other'<br>			-- (from ANY)<br>		do<br>			if other /= Void then<br>				Result := other.deep_twin<br>			end<br>		ensure -- from ANY<br>			deep_equal: deep_equal (other, Result)<br>		end<br><br>	frozen deep_copy (other: attached APPLICATION)<br>			-- Effect equivalent to that of:<br>			--		copy (`other' . deep_twin)<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>		do<br>			copy (other.deep_twin)<br>		ensure -- from ANY<br>			deep_equal: deep_equal (Current, other)<br>		end<br><br>	frozen deep_twin: attached APPLICATION<br>			-- New object structure recursively duplicated from Current.<br>			-- (from ANY)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			deep_twin_not_void: Result /= Void<br>			deep_equal: deep_equal (Current, Result)<br>		end<br><br>	frozen standard_clone (other: detachable ANY): like other<br>		obsolete "Use `standard_twin' instead."<br>			-- Void if `other' is void; otherwise new object<br>			-- field-by-field identical to `other'.<br>			-- Always uses default copying semantics.<br>			-- (from ANY)<br>		do<br>			if other /= Void then<br>				Result := other.standard_twin<br>			end<br>		ensure -- from ANY<br>			equal: standard_equal (Result, other)<br>		end<br><br>	frozen standard_copy (other: attached APPLICATION)<br>			-- Copy every field of `other' onto corresponding field<br>			-- of current object.<br>			-- (from ANY)<br>		require -- from ANY<br>			other_not_void: other /= Void<br>			type_identity: same_type (other)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			is_standard_equal: standard_is_equal (other)<br>		end<br><br>	frozen standard_twin: attached APPLICATION<br>			-- New object field-by-field identical to `other'.<br>			-- Always uses default copying semantics.<br>			-- (from ANY)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			standard_twin_not_void: Result /= Void<br>			equal: standard_equal (Result, Current)<br>		end<br><br>	frozen twin: attached APPLICATION<br>			-- New object equal to `Current'<br>			-- twin calls copy; to change copying/twinning semantics, redefine copy.<br>			-- (from ANY)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			twin_not_void: Result /= Void<br>			is_equal: Result ~ Current<br>		end<br>	<br>feature -- Basic operations<br><br>	frozen as_attached: attached APPLICATION<br>			-- Attached version of Current<br>			-- (Can be used during transitional period to convert<br>			-- non-void-safe classes to void-safe ones.)<br>			-- (from ANY)<br>		do<br>			Result := Current<br>		end<br><br>	frozen default: detachable APPLICATION<br>			-- Default value of object's type<br>			-- (from ANY)<br>		do<br>		end<br><br>	frozen default_pointer: POINTER<br>			-- Default value of type `POINTER'<br>			-- (Avoid the need to write `p'.default for<br>			-- some `p' of type `POINTER'.)<br>			-- (from ANY)<br>		do<br>		end<br><br>	default_rescue<br>			-- Process exception for routines with no Rescue clause.<br>			-- (Default: do nothing.)<br>			-- (from ANY)<br>		do<br>		end<br><br>	frozen do_nothing<br>			-- Execute a null action.<br>			-- (from ANY)<br>		do<br>		end<br>	<br>feature {NONE} -- Implementation<br><br>	internal_argument_array: ARRAY [STRING_8]<br>			-- Array containing command name (position 0) and arguments<br>			-- (from ARGUMENTS)<br>		local<br>			i: INTEGER_32<br>		do<br>			create Result.make_filled ("", 0, argument_count)<br>			Result.compare_objects<br>			from<br>			until<br>				i > argument_count<br>			loop<br>				Result.put (argument (i), i)<br>				i := i + 1<br>			end<br>		ensure -- from ARGUMENTS<br>			internal_argument_array_not_void: Result /= Void<br>			internal_argument_array_compare_objects: Result.object_comparison<br>		end<br><br>	Internal_arguments: ARGUMENTS_32<br>			-- Access to the Unicode arguments.<br>			-- (from ARGUMENTS)<br>		once<br>			create Result<br>		end<br><br>	option_character_equal (arg: STRING_8; c: CHARACTER_8): BOOLEAN<br>			-- Does `arg' contain the character option `c'?<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			arg_not_void: arg /= Void<br>		do<br>			if Option_sign.item = '%U' then<br>				Result := arg.has (c)<br>			elseif arg.item (1) = Option_sign.item then<br>				Result := arg.substring (2, arg.count).has (c)<br>			end<br>		end<br><br>	option_word_begins_with (arg, w: STRING_8): BOOLEAN<br>			-- Does `arg' begin with the word option `w'?<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			arg_not_void: arg /= Void<br>			w_not_void: w /= Void<br>		do<br>			if Option_sign.item = '%U' and then arg.count >= w.count then<br>				Result := arg.substring (1, w.count) ~ w<br>			elseif arg.item (1) = Option_sign.item and then arg.count > w.count then<br>				Result := arg.substring (2, w.count + 1) ~ w<br>			end<br>		end<br><br>	option_word_equal (arg, w: STRING_8): BOOLEAN<br>			-- Is `arg' equal to the word option `w'?<br>			-- (from ARGUMENTS)<br>		require -- from ARGUMENTS<br>			arg_not_void: arg /= Void<br>			w_not_void: w /= Void<br>		do<br>			if Option_sign.item = '%U' then<br>				Result := arg ~ w<br>			elseif not arg.is_empty and then arg.item (1) = Option_sign.item then<br>				Result := arg.substring (2, arg.count) ~ w<br>			end<br>		end<br>	<br>feature -- Access: Cursor<br><br>	new_cursor: ITERATION_CURSOR [STRING_8]<br>			-- Fresh cursor associated with current structure<br>			-- (from ARGUMENTS)<br>		do<br>			Result := Argument_array.new_cursor<br>		ensure -- from ITERABLE<br>			result_attached: Result /= Void<br>		end<br>	<br>feature -- Output<br><br>	Io: STD_FILES<br>			-- Handle to standard file setup<br>			-- (from ANY)<br>		once<br>			create Result<br>			Result.set_output_default<br>		ensure -- from ANY<br>			io_not_void: Result /= Void<br>		end<br><br>	out: STRING_8<br>			-- New string containing terse printable representation<br>			-- of current object<br>			-- (from ANY)<br>		do<br>			Result := tagged_out<br>		ensure -- from ANY<br>			out_not_void: Result /= Void<br>		end<br><br>	print (o: detachable ANY)<br>			-- Write terse external representation of `o'<br>			-- on standard output.<br>			-- (from ANY)<br>		do<br>			if o /= Void then<br>				Io.put_string (o.out)<br>			end<br>		end<br><br>	frozen tagged_out: STRING_8<br>			-- New string containing terse printable representation<br>			-- of current object<br>			-- (from ANY)<br>		external<br>			"built_in"<br>		ensure -- from ANY<br>			tagged_out_not_void: Result /= Void<br>		end<br>	<br>feature -- Platform<br><br>	Operating_environment: OPERATING_ENVIRONMENT<br>			-- Objects available from the operating system<br>			-- (from ANY)<br>		once<br>			create Result<br>		ensure -- from ANY<br>			operating_environment_not_void: Result /= Void<br>		end<br>	<br>feature {NONE} -- Retrieval<br><br>	frozen internal_correct_mismatch<br>			-- Called from runtime to perform a proper dynamic dispatch on `correct_mismatch'<br>			-- from MISMATCH_CORRECTOR.<br>			-- (from ANY)<br>		local<br>			l_msg: STRING_8<br>			l_exc: EXCEPTIONS<br>		do<br>			if attached {MISMATCH_CORRECTOR} Current as l_corrector then<br>				l_corrector.correct_mismatch<br>			else<br>				create l_msg.make_from_string ("Mismatch: ")<br>				create l_exc<br>				l_msg.append (generating_type.name)<br>				l_exc.raise_retrieval_exception (l_msg)<br>			end<br>		end<br>	<br>feature -- SCOOP<br><br>	frozen set_handler_active (a_obj: ANY)<br>			-- (from ANY)<br>		external<br>			"C inline use %"eif_macros.h%""<br>		alias<br>			"EIF_SET_ACTIVE(eif_access($a_obj))"<br>		end<br><br>	frozen set_handler_passive (a_obj: ANY)<br>			-- (from ANY)<br>		external<br>			"C inline use %"eif_macros.h%""<br>		alias<br>			"EIF_SET_PASSIVE(eif_access($a_obj))"<br>		end<br>	<br>invariant<br>		-- from ARGUMENTS<br>	argument_array_consistent: Argument_array ~ internal_argument_array<br><br>		-- from ANY<br>	reflexive_equality: standard_is_equal (Current)<br>	reflexive_conformance: conforms_to (Current)<br><br>end -- class APPLICATION<br><br>